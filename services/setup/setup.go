package setup

import (
	"io/fs"
	"os"
	"path/filepath"
	"strings"

	"github.com/digitalcircle-com-br/foundation/lib/redismgr"
	"github.com/digitalcircle-com-br/foundation/services/auth/hash"
	"github.com/sirupsen/logrus"
)

// loadRedis scans "keys" directory and set keys in redis based on filenames
func loadRedis() error {
	return filepath.WalkDir("keys", func(path string, d fs.DirEntry, err error) error {
		if !d.IsDir() {
			logrus.Infof("%s - %s", path, d.Name())
			kname := strings.Replace(path, "keys/", "", 1)
			kname = strings.Replace(kname, "/", ":", -1)
			ext := filepath.Ext(kname)
			if ext != "" {
				kname = strings.Replace(kname, ext, "", 1)
			}
			kval, err := os.ReadFile(path)
			if err != nil {
				return err
			}

			redismgr.Set(kname, string(kval))
		}

		return nil
	})
}

// cleanRedis scans "keys" directory and remove keys from redis based on filenames
func cleanRedis() error {
	return filepath.WalkDir("keys", func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() {
			logrus.Infof("%s - %s", path, d.Name())
			kname := strings.Replace(path, "keys/", "", 1)
			kname = strings.Replace(kname, "/", ":", -1)
			redismgr.Del(kname)
		}

		return nil
	})
}

// Clean deletes keys from redis
func Clean() error {
	return cleanRedis()
}

// Load create keys in redis
func Load() error {
	return loadRedis()
}

// func prepareMigrations() {
// 	dbmgr.MigrationAdd("auth-00001", "Creates Authentication DB",
// 		func(s string) bool {
// 			return s == "auth"
// 		},
// 		func(adb *gorm.DB) error {
// 			for _, mod := range []interface{}{
// 				&fmodel.SecUser{},
// 				&fmodel.SecGroup{},
// 				&fmodel.SecPerm{},
// 			} {
// 				err := adb.AutoMigrate(mod)
// 				if err != nil {
// 					return err
// 				}
// 			}

// 			perm := &fmodel.SecPerm{Name: "*", Val: "*"}
// 			err := adb.Create(perm).Error
// 			if err != nil {
// 				return err
// 			}
// 			group := &fmodel.SecGroup{Name: "root", Perms: []*fmodel.SecPerm{perm}}
// 			err = adb.Create(group).Error
// 			if err != nil {
// 				return err
// 			}
// 			enabled := true

// 			user := &fmodel.SecUser{
// 				Username: "root",
// 				Hash:     "$argon2id$v=19$m=65536,t=3,p=2$nTPFgXmlMFphn506a/VQ2Q$0Y/KXMMxDb28CzuqGZdShAnNuNs3l3vInJRh3xd5uq4",
// 				Email:    "root@root.com",
// 				Enabled:  &enabled, Groups: []*fmodel.SecGroup{group},
// 			}

// 			err = adb.Create(user).Error
// 			if err != nil {
// 				return err
// 			}
// 			return nil

// 		})

// }

// func Run() error {
// 	core.Init("setup")
// 	dsns, err := dbmgr.DSNS()
// 	if err != nil {
// 		return err
// 	}
// 	mdb, err := dbmgr.DBN("postgres")
// 	if err != nil {
// 		return err
// 	}
// 	for _, dsn := range dsns {
// 		if dsn != "postgres" {
// 			err = mdb.Exec(fmt.Sprintf("CREATE DATABASE %s;", dsn)).Error
// 			if err != nil {
// 				log.Printf("DB Creation: %s", err.Error())
// 			}
// 		}
// 	}

// 	prepareMigrations()
// 	dbmgr.MigrationRun()

// 	return nil
// }

// func Drop() error {
// 	core.Init("setup")
// 	dsns, err := dbmgr.DSNS()
// 	if err != nil {
// 		return err
// 	}
// 	mdb, err := dbmgr.DBN("postgres")
// 	if err != nil {
// 		log.Printf("could not connect to master dbmgr.")
// 		return nil
// 	}
// 	for _, dsn := range dsns {
// 		if dsn != "postgres" {

// 			err = mdb.Exec(fmt.Sprintf("DROP DATABASE %s;", dsn)).Error
// 			if err != nil {
// 				log.Printf("DB Creation: %s", err.Error())
// 			}
// 		}
// 	}

// 	return nil
// }

// CreatePassHash returns hash generated by argon2id
func CreatePassHash(in string) (string, error) {
	return hash.Hash(in)
}
